// filepath: src/lib/transactionUtils.ts
import * as d3 from 'd3';

// Define the structure based on your sample JSON generated by the script
export type Transaction = {
  account_id: string;
  amount: number; // ALWAYS POSITIVE based on generation script
  category: string[] | null;
  category_id: string | null;
  date: string; // Assumed 'YYYY-MM-DD'
  iso_currency_code: string;
  merchant_name: string | null;
  name: string;
  pending: boolean;
  transaction_id: string;
  personal_finance_category?: {
    primary: string;
    detailed: string;
    confidence_level?: string;
  } | null;
  // Add other fields if present in your JSON
};

export interface MonthlyIncomeExpense {
  month: Date;
  income: number; // Total positive value of income
  expense: number; // Total positive value of expense
}

export interface CategoryTotal {
  category: string;
  total: number; // Always positive value
}

export interface DailyActivity {
  date: Date;
  netAmount: number; // Income - Expense
  income: number; // Total positive value of income
  expense: number; // Total positive value of expense
}

// --- Helper: Determine if Income based on Category ---
// CRITICAL: Adjust this list based on categories assigned to INCOME in your Python script's CATEGORY_MAP
const INCOME_PRIMARY_CATEGORIES = new Set(['Transfer', 'Deposit', 'Payroll']); // Add others if needed

function isIncomeTransaction(tx: Transaction): boolean {
    // Check if the primary category indicates income
    return !!tx.category && tx.category.length > 0 && INCOME_PRIMARY_CATEGORIES.has(tx.category[0]);
    // Add fallback logic using tx.name if category is unreliable for income
    // e.g., || tx.name?.toLowerCase().includes('payout') || tx.name?.toLowerCase().includes('deposit')
}

// --- Date Parsing ---
const memoizedDateParser = (() => {
    const cache = new Map<string, Date | null>();
    const parser = d3.timeParse("%Y-%m-%d");
    return (dateString: string): Date | null => {
        if (!dateString) return null;
        if (cache.has(dateString)) {
            return cache.get(dateString)!;
        }
        const parsed = parser(dateString);
        cache.set(dateString, parsed);
        return parsed;
    };
})();

// --- Category Helper (Focuses on Display Name) ---
// CRITICAL: Customize this function based on YOUR data and desired categories
function getDisplayCategory(tx: Transaction): string {
    // Define categories to generally ignore for specific display charts (like expense breakdown)
    const ignoredDisplayCategories = ["Payment", "Transfer", "Credit Card", "Deposit", "Payroll"];

    // Prefer Plaid primary category if available and not ignored for display
    if (tx.category && tx.category.length > 0 && !ignoredDisplayCategories.includes(tx.category[0])) {
        // You might want to map specific primary categories to better names here
        // e.g., if (tx.category[0] === 'Gas Stations') return 'Fuel';
        return tx.category[0];
    }

    // Fallback using keywords in name for common gig expenses/income
    const txNameLower = tx.name?.toLowerCase() || '';
    const keywords: { [key: string]: string } = {
        'uber': 'Uber', 'lyft': 'Lyft', 'doordash': 'DoorDash', // Income examples
        'gas': 'Fuel', 'shell': 'Fuel', 'exxon': 'Fuel', // Expense examples
        'toll': 'Tolls', 'parking': 'Parking',
        'restaurant': 'Food & Drink', 'cafe': 'Food & Drink',
        'shipping': 'Shipping', 'supplies': 'Supplies',
        'subscription': 'Subscription', 'software': 'Software',
        // Add many more based on your data and desired chart labels
    };
     for (const keyword in keywords) {
        if (txNameLower.includes(keyword)) {
            return keywords[keyword];
        }
    }

    // Further fallback using personal finance category
    if (tx.personal_finance_category?.primary && !ignoredDisplayCategories.includes(tx.personal_finance_category.primary)) {
         return tx.personal_finance_category.primary.replace(/_/g, ' '); // Format it
    }

    // If it's determined as income but not specifically categorized above
    if (isIncomeTransaction(tx)) {
        return 'Other Income';
    }

    return 'Other Expense'; // Default fallback if nothing else matches
}


// --- Processing Function for Monthly Income/Expense ---
export function processMonthlyIncomeExpense(transactions: Transaction[]): MonthlyIncomeExpense[] {
  if (!transactions || transactions.length === 0) return [];

  const monthlyRollup = d3.rollups(
    transactions.filter(tx => tx.date), // Ensure date exists
    (v: Transaction[]) => {
      // Determine income/expense based on category, amount is always positive
      const income = d3.sum(v, d => (isIncomeTransaction(d) ? d.amount : 0));
      const expense = d3.sum(v, d => (!isIncomeTransaction(d) ? d.amount : 0));
      return { income, expense };
    },
    (d: Transaction) => d.date.slice(0, 7) // Group by YYYY-MM
  );

  const parseMonth = d3.timeParse("%Y-%m");
  const result = monthlyRollup
    .map(([monthStr, values]) => ({
      month: parseMonth(monthStr)!,
      income: values.income,
      expense: values.expense,
    }))
    .filter(d => d.month instanceof Date && !isNaN(d.month.getTime()))
    .sort((a, b) => a.month.getTime() - b.month.getTime());

  return result;
}

// --- Processing Function for Category Totals (Income or Expense) ---
export function processCategoryTotals(transactions: Transaction[], type: 'income' | 'expense'): CategoryTotal[] {
  if (!transactions || transactions.length === 0) return [];

  // Filter based on income/expense category determination
  const filtered = transactions.filter(tx => isIncomeTransaction(tx) === (type === 'income'));

  const categoryRollup = d3.rollups(
    filtered,
    (v: Transaction[]) => d3.sum(v, d => d.amount), // Sum positive amounts
    (d: Transaction) => getDisplayCategory(d) // Use the helper to get display category name
  );

  const result = categoryRollup
    // Optionally filter out generic categories like 'Other Income'/'Other Expense' if desired
    .filter(([category, total]) => !['Other Income', 'Other Expense', 'Uncategorized'].includes(category) && total > 0)
    .map(([category, total]) => ({
      category: category!,
      total: total,
    }))
    .sort((a, b) => b.total - a.total); // Sort descending by total

  return result;
}


// --- Processing Function for Daily Activity (for Heatmap) ---
export function processDailyActivity(transactions: Transaction[]): Map<string, DailyActivity> {
    const dailyMap = new Map<string, DailyActivity>();
    if (!transactions || transactions.length === 0) return dailyMap;

    transactions.forEach(tx => {
        if (!tx.date) return;
        const dateStr = tx.date;
        const parsedDate = memoizedDateParser(dateStr);
        if (!parsedDate) return;

        const dayData = dailyMap.get(dateStr) || { date: parsedDate, netAmount: 0, income: 0, expense: 0 };
        const isIncome = isIncomeTransaction(tx);

        if (isIncome) {
            dayData.income += tx.amount;
            dayData.netAmount += tx.amount; // Income increases net
        } else {
            dayData.expense += tx.amount;
            dayData.netAmount -= tx.amount; // Expense decreases net
        }
        dailyMap.set(dateStr, dayData);
    });

    return dailyMap;
}
